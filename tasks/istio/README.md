# This task has been tested on GKE and bare metal K8s with metallb setup
* GKE 1.14.6-gke.13 cluster with 2 worker nodes (2 vCPU / 7.5 GB)
* Bare metal Kubernetes version: v1.15.3
* Helm 2.14.3
* metallb/controller:v0.8.1 (Only required by bare metal setup)
* Istio 1.3.3 with sds enabled, certmanager, grafana and kiali
* $INGRESS_DOMAIN -> HTTPS (443) secured by Let's encrypt CA via Haproxy -> istio-autogenerated-k8s-ingress
* $TOM_INGRESS_DOMAIN -> HTTP (80) via Haproxy -> istio-autogenerated-k8s-ingress
* $KIALI_INGRESS_DOMAIN -> HTTP (80) via Haproxy -> istio-autogenerated-k8s-ingress
* $GRAFANA_INGRESS_DOMAIN -> HTTP (80) via Haproxy -> istio-autogenerated-k8s-ingress
* Ingress control via istio gateway istio-autogenerated-k8s-ingress
* uri request control in separated virtualservice
* Istio gateway istio-autogenerated-k8s-ingress exposed as a service type LoadBalancer (metallb)

# Istio release setup
```
curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.3.3 sh -
cd istio-1.3.3
export PATH=$PWD/bin:$PATH
istioctl verify-install
```

# Install all the Istio Custom Resource Definitions (CRDs)
```for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done```

# Istio-init
```
kubectl create namespace istio-system
helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl apply -f -
```

# Create a secret for Kiali
```
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: kiali
  namespace: $(echo -n istio-system)
  labels:
    app: kiali
type: Opaque
data:
  username: $(echo -n admin | base64)
  passphrase: $(echo -n pass | base64)
EOF
```

# Istio with sds/certmanager/grafana/kiali
```
echo ISSUER_EMAIL: && \
read ISSUER_EMAIL && \
helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=$ISSUER_EMAIL \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl apply -f -
```

# modify the tls section of gateway/istio-autogenerated-k8s-ingress to sds
```
kubectl -n istio-system \
  patch gateway istio-autogenerated-k8s-ingress --type=json \
  -p='[{"op": "replace", "path": "/spec/servers/1/tls", "value": {"credentialName": "ingress-cert", "mode": "SIMPLE", "privateKey": "sds", "serverCertificate": "sds"}}]'
```

# Enable istio injection to default namespace
```kubectl label ns default istio-injection=enabled```

# helloworld deployment, service and virtualservice
```
echo INGRESS_DOMAIN: && \
read INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: helloworld
  labels:
    app: helloworld
spec:
  ports:
  - port: 5000
    name: http
  selector:
    app: helloworld
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld
spec:
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: helloworld
        image: istio/examples-helloworld-v1
        resources:
          requests:
            cpu: "100m"
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 5000
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: helloworld-vs
spec:
  hosts:
  - $INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /hello
    route:
    - destination:
        host: helloworld
        port:
          number: 5000
EOF
```

# Make sure DNS A record is set for INGRESS_DOMAIN resolving Load Balancer public ip.
* [IMPORTANT] If you are on bare metal setup, A DNS A record resolving a Haproxy host public ip address is a MUST because metallb load balancer ip is a priviate ip which is only accessible within K8s container network.  We will need to deploy a worker node to accessing metallb ip as well as serving HTTP/HTTPS requests at a public ip address, that's Haproxy comes in as a proxy service for external-internal routing.
* https://github.com/henryliu18/kubernetes-poc/tree/master/tasks/Haproxy-build-for-metallb

# Now you should be able to access helloworld application via HTTP
```curl http://$INGRESS_DOMAIN/hello```

# Getting a Letâ€™s Encrypt certificate issued using cert-manager
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt-staging
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# At this point the service should become available over HTTPS as well

```curl --insecure https://$INGRESS_DOMAIN/hello```

# [IMPORTANT] If you are getting below errors, delete istio-ingressgateway pod to make it restarting should work this around.
* curl: (35) Encountered end of file
* curl: (7) Failed connect to hello.istio.io:443; Connection refused

# Moving to production from staging
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# Now delete the secret to force cert-manager to request a new certificate from the production issuer
```kubectl delete secret -n istio-system ingress-cert```

# watch that cert for a successful issuance
```watch -n1 kubectl describe cert ingress-cert -n istio-system```

# [IMPORTANT] HTTPS with legit certifiate should work, if not, just delete istio-ingressgateway pod :)
```curl https://$INGRESS_DOMAIN/hello```

# Deploy a Tomcat deployment, service and virtualservice
```
echo TOM_INGRESS_DOMAIN: && \
read TOM_INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: tomcat
  name: tomcat-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: tomcat
  template:
    metadata:
      labels:
        app: tomcat
    spec:
      containers:
      - image: tomcat:alpine
        name: tomcat
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: tomcat-service
  labels:
    app: tomcat
spec:
  ports:
  - port: 8080
    name: http
    protocol: TCP
    targetPort: 8080
  selector:
    app: tomcat
  type: ClusterIP
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: tomcat-vs
spec:
  hosts:
  - $TOM_INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: tomcat-service
        port:
          number: 8080
EOF
```
# Make sure $TOM_INGRESS_DOMAIN is resolved to Load Balancer ip address
```curl http://$TOM_INGRESS_DOMAIN/```

# Kiali should be exposed at ClusterIP:20001
```kubectl get service kiali -n istio-system```

# Create virtualservice for ingress control Kiali so we can access Kiali console through Haproxy -> Istio ingressgateway
```
echo KIALI_INGRESS_DOMAIN: && \
read KIALI_INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: kiali-vs
  namespace: istio-system
spec:
  hosts:
  - $KIALI_INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: kiali
        port:
          number: 20001
EOF
```
* Make sure $KIALI_INGRESS_DOMAIN pointing to Haproxy public ip
```curl http://$KIALI_INGRESS_DOMAIN/kiali```

# Grafana should be exposed at ClusterIP:3000
```kubectl get service grafana -n istio-system```

# Create virtualservice for ingress control Grafana so we can access Grafana console through Haproxy -> Istio ingressgateway
```
echo GRAFANA_INGRESS_DOMAIN: && \
read GRAFANA_INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: grafana-vs
  namespace: istio-system
spec:
  hosts:
  - $GRAFANA_INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: grafana
        port:
          number: 3000
EOF
```
* Make sure $GRAFANA_INGRESS_DOMAIN pointing to Haproxy public ip
```curl http://$GRAFANA_INGRESS_DOMAIN/```

## Cleanup
```
kubectl delete vs/tomcat-vs
kubectl delete svc/tomcat-service
kubectl delete deployment/tomcat-demo

kubectl delete vs/helloworld-vs
kubectl delete svc/helloworld
kubectl delete deployment/helloworld

kubectl delete vs/grafana-vs -n istio-system
kubectl delete vs/kiali-vs -n istio-system

kubectl label ns default istio-injection-

kubectl delete Secret/kiali -n istio-system

cd istio-*
echo ISSUER_EMAIL: && \
read ISSUER_EMAIL && \
helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=$ISSUER_EMAIL \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl delete -f -

helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl delete -f -
for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl delete -f $i; done
kubectl delete namespace istio-system
```
