# This task has been tested on GKE and bare metal K8s with metallb setup
* GKE 1.14.6-gke.13 cluster with 2 worker nodes (2 vCPU / 7.5 GB)
* Helm 2.14.3
* Istio 1.3.3 with sds enabled, certmanager, grafana and kiali
* $INGRESS_DOMAIN -> HTTPS (443) secured by Let's encrypt CA
* $TOM_INGRESS_DOMAIN -> HTTP (80)
* Both websites are ingress controlled by default istio gateway istio-autogenerated-k8s-ingress
* uri request control in separated virtualservice
* gateway istio-autogenerated-k8s-ingress via Load Balancer
* Access Kiali/Grafana via Load Balancer

# Istio release setup
```
curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.3.3 sh -
cd istio-1.3.3
export PATH=$PWD/bin:$PATH
istioctl verify-install
```

# Install all the Istio Custom Resource Definitions (CRDs)
```for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done```

# Istio-init
```
kubectl create namespace istio-system
helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl apply -f -
```

# Create a secret for Kiali
```
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: kiali
  namespace: $(echo -n istio-system)
  labels:
    app: kiali
type: Opaque
data:
  username: $(echo -n admin | base64)
  passphrase: $(echo -n pass | base64)
EOF
```

# Istio with sds/certmanager/grafana/kiali
```
helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=henry.hhl@gmail.com \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl apply -f -
```

# modify the tls section of gateway/istio-autogenerated-k8s-ingress to sds
```
kubectl -n istio-system \
  patch gateway istio-autogenerated-k8s-ingress --type=json \
  -p='[{"op": "replace", "path": "/spec/servers/1/tls", "value": {"credentialName": "ingress-cert", "mode": "SIMPLE", "privateKey": "sds", "serverCertificate": "sds"}}]'
```

# Enable istio injection to default namespace
```kubectl label ns default istio-injection=enabled```

# helloworld deployment, service and virtualservice
```
echo INGRESS_DOMAIN: && \
read INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: helloworld
  labels:
    app: helloworld
spec:
  ports:
  - port: 5000
    name: http
  selector:
    app: helloworld
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld
spec:
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: helloworld
        image: istio/examples-helloworld-v1
        resources:
          requests:
            cpu: "100m"
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 5000
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: helloworld-vs
spec:
  hosts:
  - $INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /hello
    route:
    - destination:
        host: helloworld
        port:
          number: 5000
EOF
```

# Make sure DNS A record is set for INGRESS_DOMAIN resolving Load Balancer public ip.
* [IMPORTANT] If you are on bare metal setup, A DNS A record resolving a Haproxy host public ip address is a MUST because metallb load balancer ip is a priviate ip which is only accessible within K8s container network.  We will need to deploy a worker node to accessing metallb ip as well as serving HTTP/HTTPS requests at a public ip address, that's Haproxy comes in as a proxy service for external-internal routing.
* https://github.com/henryliu18/kubernetes-poc/tree/master/tasks/Haproxy-build-for-metallb

# Now you should be able to access your demo application via HTTP
```curl http://$INGRESS_DOMAIN/hello```

# Getting a Letâ€™s Encrypt certificate issued using cert-manager
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt-staging
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# At this point the service should become available over HTTPS as well

```curl --insecure https://$INGRESS_DOMAIN/hello```

# [IMPORTANT] If you are getting below error, delete istio-ingressgateway pod to make it restarting should work this around.

* curl: (7) Failed connect to hello.istio.io:443; Connection refused

# Moving to production from staging
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# Now delete the secret to force cert-manager to request a new certificate from the production issuer
```kubectl delete secret -n istio-system ingress-cert```

# watch that cert for a successful issuance
```watch -n1 kubectl describe cert ingress-cert -n istio-system```

# [IMPORTANT] HTTPS with legit certifiate should work, if not, just delete istio-ingressgateway pod :)
```curl https://$INGRESS_DOMAIN/hello```

# Deploy a Tomcat deployment, service and virtualservice
```
echo TOM_INGRESS_DOMAIN: && \
read TOM_INGRESS_DOMAIN && \
cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    run: tomcat
  name: tomcat-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      run: tomcat
  template:
    metadata:
      labels:
        run: tomcat
    spec:
      containers:
      - image: tomcat:alpine
        name: tomcat
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: tomcat-service
spec:
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    run: tomcat
  type: ClusterIP
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: tomcat-vs
spec:
  hosts:
  - $TOM_INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: tomcat-service
        port:
          number: 8080
EOF
```
# Make sure $TOM_INGRESS_DOMAIN is resolved to Load Balancer ip address
```curl http://$TOM_INGRESS_DOMAIN/```

# Modify svc/kiali from ClusterIP to LoadBalancer
```kubectl edit svc/kiali -n istio-system```

# Get External ip from LoadBalancer
```kubectl get svc/kiali -n istio-system```
* http://LB-IP:20001/

## Cleanup
```
kubectl delete vs/tomcat-vs
kubectl delete svc/tomcat-service
kubectl delete deployment/tomcat-demo

kubectl delete vs/helloworld-vs
kubectl delete svc/helloworld
kubectl delete deployment/helloworld

kubectl label ns default istio-injection-

kubectl delete Secret/kiali -n istio-system

cd istio-*
helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=henry.hhl@gmail.com \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl delete -f -

helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl delete -f -
for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl delete -f $i; done
kubectl delete namespace istio-system
```
