# This task has been tested on GKE
* GKE cluster with 2 worker nodes
* Helm 2.14.3
* Istio 1.3.3 with sds enabled, certmanager, grafana and kiali
* hello.busyapi.com -> HTTPS secured by Let's encrypt CA
* tom.busyapi.com -> HTTP
* both websites are ingress controlled by default istio gateway istio-autogenerated-k8s-ingress
* uri request control in separated virtualservice
* Access Kiali/Grafana via Load Balancer

# Istio release setup
```
curl -L https://git.io/getLatestIstio | ISTIO_VERSION=1.3.3 sh -
cd istio-1.3.3
export PATH=$PWD/bin:$PATH
istioctl verify-install
```

# Install all the Istio Custom Resource Definitions (CRDs)
```for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done```

# Istio-init
```
kubectl create namespace istio-system
helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl apply -f -
```

## Create a secret for Kiali
```
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: kiali
  namespace: $(echo -n istio-system)
  labels:
    app: kiali
type: Opaque
data:
  username: $(echo -n admin | base64)
  passphrase: $(echo -n pass | base64)
EOF
```

# Istio with sds/certmanager/grafana/kiali
```
helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=henry.hhl@gmail.com \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl apply -f -
```

# modify the tls section
```
kubectl -n istio-system \
  patch gateway istio-autogenerated-k8s-ingress --type=json \
  -p='[{"op": "replace", "path": "/spec/servers/1/tls", "value": {"credentialName": "ingress-cert", "mode": "SIMPLE", "privateKey": "sds", "serverCertificate": "sds"}}]'
```

# demo helloworld
```
INGRESS_DOMAIN=hello.busyapi.com
kubectl label ns default istio-injection=enabled
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Service
metadata:
  name: helloworld
  labels:
    app: helloworld
spec:
  ports:
  - port: 5000
    name: http
  selector:
    app: helloworld
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: helloworld
spec:
  template:
    metadata:
      labels:
        app: helloworld
    spec:
      containers:
      - name: helloworld
        image: istio/examples-helloworld-v1
        resources:
          requests:
            cpu: "100m"
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 5000
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    kubernetes.io/ingress.class: istio
  name: helloworld-ingress
spec:
  rules:
    - host: "$INGRESS_DOMAIN"
      http:
        paths:
          - path: /hello
            backend:
              serviceName: helloworld
              servicePort: 5000
---
EOF
```

# Now you should be able to access your demo application via HTTP

```curl http://$INGRESS_DOMAIN/hello```

# Getting a Letâ€™s Encrypt certificate issued using cert-manager
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt-staging
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# At this point the service should become available over HTTPS as well

```curl --insecure https://$INGRESS_DOMAIN/hello```

# [IMPORTANT] If you are getting below error, delete istio-ingressgateway pod to make it restarting should work this around.

* curl: (7) Failed connect to hello.istio.io:443; Connection refused

# Moving to production from staging
```
cat <<EOF | kubectl apply -f -
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: ingress-cert
  namespace: istio-system
spec:
  secretName: ingress-cert
  issuerRef:
    name: letsencrypt
    kind: ClusterIssuer
  commonName: $INGRESS_DOMAIN
  dnsNames:
  - $INGRESS_DOMAIN
  acme:
    config:
    - http01:
        ingressClass: istio
      domains:
      - $INGRESS_DOMAIN
---
EOF
```

# Now delete the secret to force cert-manager to request a new certificate from the production issuer
```kubectl delete secret -n istio-system ingress-cert```

# watch that cert for a successful issuance
```watch -n1 kubectl describe cert ingress-cert -n istio-system```

# [IMPORTANT] HTTPS with legit certifiate should work, if not, just delete istio-ingressgateway pod :)
```curl https://$INGRESS_DOMAIN/hello```

# Migrate Ingress to VirtualService for advanced traffic management
```
kubectl delete Ingress/helloworld-ingress

cat <<EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: helloworld-vs
spec:
  hosts:
  - $INGRESS_DOMAIN
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /hello
    route:
    - destination:
        host: helloworld
        port:
          number: 5000
---
EOF
```

# Deploy a Tomcat deployment, service and virtualservice
```
cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    run: tomcat
  name: tomcat-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      run: tomcat
  template:
    metadata:
      labels:
        run: tomcat
    spec:
      containers:
      - image: tomcat:alpine
        name: tomcat
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: tomcat-service
spec:
  ports:
  - port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    run: tomcat
  type: ClusterIP
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: tomcat-vs
spec:
  hosts:
  - 'tom.busyapi.com'
  gateways:
  - istio-system/istio-autogenerated-k8s-ingress
  http:
  - match:
    - uri:
        prefix: /
    route:
    - destination:
        host: tomcat-service
        port:
          number: 8080
EOF
```
# Make sure tom.busyapi.com is resolved to Load Balancer ip address and navigate to http://tom.busyapi.com/

# Modify svc/kiali from ClusterIP to LoadBalancer
```kubectl edit svc/kiali -n istio-system```

# Get External ip from LoadBalancer
```kubectl get svc/kiali -n istio-system```
* http://LB-IP:20001/

## Cleanup
```
kubectl delete vs/tomcat-vs
kubectl delete svc/tomcat-service
kubectl delete deployment/tomcat-demo

kubectl delete vs/helloworld-vs
kubectl delete svc/helloworld
kubectl delete deployment/helloworld

kubectl label ns default istio-injection-

kubectl delete Secret/kiali -n istio-system

helm template install/kubernetes/helm/istio \
       --name istio \
       --namespace istio-system \
       --set gateways.istio-ingressgateway.sds.enabled=true \
       --set global.k8sIngress.enabled=true \
       --set global.k8sIngress.enableHttps=true \
       --set global.k8sIngress.gatewayName=ingressgateway \
       --set certmanager.enabled=true \
       --set certmanager.email=henry.hhl@gmail.com \
       --set grafana.enabled=True \
       --set kiali.enabled=True | kubectl delete -f -

helm template install/kubernetes/helm/istio-init --name istio-init --namespace istio-system | kubectl delete -f -
kubectl delete namespace istio-system
```
